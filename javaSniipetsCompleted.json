{
    "Basic Java Class": {
        "prefix": "class",
        "body": [
            "public class ${1:ClassName} {",
            "public static void main(String[] args) {",
            "$0 //main method body",
            "}",
            "}"
        ],
        "description": "Java class with a main."
    },
    "Basic Java Method": {
        "prefix": "method",
        "body": [
            "public ${1:void} ${2:methodName}(${3:parameters}){",
            "\t${4://method body}",
            "}"
        ],
        "description": "Basic Java Method Template"
    },
    "Basic Java Constructor": {
        "prefix": "BasicConstructor",
        "body": [
            "public ${1:ClassName}($2){",
            "    ${3://constructor body}",
            "}"
        ],
        "description": "Java Constructor Basic Template"
    },
    "Basic Java Single Try-Catch Block": {
        "prefix": "singleTryCatch",
        "body": [
            "try {",
            "    ${1://try block}",
            "}",
            "catch (${2:Exception e}){",
            "    ${3://catch block}",
            "}"
        ],
        "description": "Single Try-Catch Exception e Template"
    },
    "Basic Java For Loop": {
        "prefix": "for",
        "body": [
            "for (int ${1:i} = 0; ${2:i} < ${3:array.length}; ${4:i++}){",
            "\t$0",
            "}"
        ],
        "description": "For Loop Template"
    },
    "Basic Java If-Else Statement": {
        "prefix": "ifelse",
        "body": [
            "if($1:condition){",
            "$2:// if block",
            "}",
            "else{",
            "$3:// else block",
            "}"
        ],
        "description": "If else control flow template"
    },
    "Basic Java Getter": {
        "prefix": "getter",
        "body": [
            "public ${1:ReturnType} get${2:FieldName}() {",
            "return${FieldName}",
            "}"
        ],
        "description": "Basic Java Getter Template"
    },
    "Java List Initializaiton": {
        "prefix": "arrayList",
        "body": [
            "List<${1:Type}> ${2:listName} = new ArrayList<>();"
        ],
        "description": "ArrayList Initalization"
    },
    "Java Map Initialization": {
        "prefix": "hashmap",
        "body": [
            "Map<${1:Key}, ${2:Value}> ${3:mapName} = new HashMap<>();"
        ],
        "description": "HashMap Initialization"
    },
    "Java Enhanced For Loop": {
        "prefix": "javaEnhancedForLoop",
        "body": [
            "for (${1:Type} ${2:element} : ${3:collection}) {",
            "    ${4:// loop body}",
            "}"
        ],
        "description": "Creates an enhanced for loop"
    },
    "Java toString": {
        "prefix": "javaToString",
        "body": [
            "@Override",
            "public String toString() {",
            "    return \"${1:ClassName}{\" +",
            "           \"${2:field}='\" + ${2:field} + '\\'' +",
            "           '}';",
            "}"
        ],
        "description": "Creates a toString method"
    },
    "Java Set Initialization": {
        "prefix": "set",
        "body": [
            "Set<${1:Type}> ${2:setName} = new HashSet<>();"
        ],
        "description": "Creates a Set"
    },
    "Java Queue Initialization": {
        "prefix": "Queue",
        "body": [
            "Queue<${1:Type}> ${2:queueName} = new LinkedList<>();"
        ],
        "description": "Creates a Queue initialization"
    },
    "Java LinkedList Initialization": {
        "prefix": "linkedList",
        "body": [
            "LinkedList<${1:Type}> ${2:listName} = new LinkedList<>();"
        ],
        "description": "Creates a LinkedList initialization"
    },
    "Java Stack Initialization": {
        "prefix": "stack",
        "body": [
            "Stack<${1:Type}> ${2:stackName} = new Stack<>();"
        ],
        "description": "Creates a Stack initialization"
    },
    "Java HashMap Initialization": {
        "prefix": "hashMap",
        "body": [
            "HashMap<${1:KeyType}, ${2:ValueType}> ${3:mapName} = new HashMap<>();"
        ],
        "description": "Creates a HashMap initialization"
    },
    "Java Check if Stack is Not Empty": {
        "prefix": "stackNotEmpty",
        "body": [
            "if (!${1:stack}.isEmpty()) {",
            "    // Your code here",
            "}"
        ],
        "description": "Check if a stack is not empty"
    },
    "Java Add Element to List": {
        "prefix": "listAdd",
        "body": [
            "${1:list}.add(${2:element});"
        ],
        "description": "Add an element to a list"
    },
    "Java Add Key-Value Pair to Map": {
        "prefix": "mapPut",
        "body": [
            "${1:map}.put(${2:key}, ${3:value});"
        ],
        "description": "Add a key-value pair to a map"
    },
    "Java Iterate Over List": {
        "prefix": "listIterate",
        "body": [
            "for (${1:Type} ${2:element} : ${3:list}) {",
            "    // Your code here",
            "}"
        ],
        "description": "Iterate over a list"
    },
    "Java Iterate Over Map": {
        "prefix": "mapIterate",
        "body": [
            "for (Map.Entry<${1:KeyType}, ${2:ValueType}> ${3:entry} : ${4:map}.entrySet()) {",
            "    ${1:KeyType} ${5:key} = ${3:entry}.getKey();",
            "    ${2:ValueType} ${6:value} = ${3:entry}.getValue();",
            "    // Your code here",
            "}"
        ],
        "description": "Iterate over a map"
    },
    "Java Check if Map Contains Key": {
        "prefix": "mapContainsKey",
        "body": [
            "if (${1:map}.containsKey(${2:key})) {",
            "    // Your code here",
            "}"
        ],
        "description": "Check if a map contains a key"
    },
    "Java Check if List Contains Element": {
        "prefix": "listContains",
        "body": [
            "if (${1:list}.contains(${2:element})) {",
            "    // Your code here",
            "}"
        ],
        "description": "Check if a list contains an element"
    },
    "Java Print to Console": {
        "prefix": "printLine",
        "body": [
            "System.out.println(\"${1:Your message here}\");"
        ],
        "description": "Print to console"
    },
    "Java Generic Method Signature": {
        "prefix": "methodSignature",
        "body": [
            "public ${1:ReturnType} ${2:methodName}(${3:ParameterType} ${4:parameter}) {",
            "    // Your code here",
            "    return ${5:returnValue};",
            "}"
        ],
        "description": "Generic method signature"
    },
    "Java Main Method": {
        "prefix": "mainMethod",
        "body": [
            "public static void main(String[] args) {",
            "    // Your code here",
            "}"
        ],
        "description": "Main method"
    },
    "Java Create a New Object": {
        "prefix": "newObject",
        "body": [
            "${1:ClassName} ${2:objectName} = new ${1:ClassName}();"
        ],
        "description": "Create a new object"
    },
    "Java Define an Interface": {
        "prefix": "defineInterface",
        "body": [
            "public interface ${1:InterfaceName} {",
            "    ${2:returnType} ${3:methodName}(${4:parameterType} ${5:parameter});",
            "}"
        ],
        "description": "Define an interface"
    },
    "Java Implement an Interface": {
        "prefix": "implementInterface",
        "body": [
            "public class ${1:ClassName} implements ${2:InterfaceName} {",
            "    @Override",
            "    public ${3:returnType} ${4:methodName}(${5:parameterType} ${6:parameter}) {",
            "        // Your code here",
            "    }",
            "}"
        ],
        "description": "Implement an interface"
    },
    "Java Constructor Dependency Injection": {
        "prefix": "constructorDI",
        "body": [
            "public class ${1:ClassName} {",
            "    private final ${2:DependencyType} ${3:dependency};",
            "",
            "    public ${1:ClassName}(${2:DependencyType} ${3:dependency}) {",
            "        this.${3:dependency} = ${3:dependency};",
            "    }",
            "",
            "    public void ${4:methodName}() {",
            "        ${3:dependency}.${5:dependencyMethod}();",
            "    }",
            "}"
        ],
        "description": "Constructor dependency injection"
    },
    "Java Single Responsibility Principle": {
        "prefix": "singleResponsibility",
        "body": [
            "public class ${1:ClassName} {",
            "    public void ${2:method1}() {",
            "        // Responsibility 1",
            "    }",
            "",
            "    public void ${3:method2}() {",
            "        // Responsibility 2",
            "    }",
            "}"
        ],
        "description": "Single Responsibility Principle"
    },
    "Java Open/Closed Principle": {
        "prefix": "openClosed",
        "body": [
            "public abstract class ${1:BaseClass} {",
            "    public abstract void ${2:baseMethod}();",
            "}",
            "",
            "public class ${3:DerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:baseMethod}() {",
            "        // Implementation",
            "    }",
            "}"
        ],
        "description": "Open/Closed Principle"
    },
    "Java Liskov Substitution Principle": {
        "prefix": "liskovSubstitution",
        "body": [
            "public class ${1:BaseClass} {",
            "    public void ${2:baseMethod}() {",
            "        // Base implementation",
            "    }",
            "}",
            "",
            "public class ${3:DerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:baseMethod}() {",
            "        // Derived implementation",
            "    }",
            "}",
            "",
            "public void useBaseClass(${1:BaseClass} ${4:baseInstance}) {",
            "    ${4:baseInstance}.${2:baseMethod}();",
            "}"
        ],
        "description": "Liskov Substitution Principle"
    },
    "Java Interface Segregation Principle": {
        "prefix": "interfaceSegregation",
        "body": [
            "public interface ${1:Interface1} {",
            "    void ${2:method1}();",
            "}",
            "",
            "public interface ${3:Interface2} {",
            "    void ${4:method2}();",
            "}",
            "",
            "public class ${5:ClassName} implements ${1:Interface1}, ${3:Interface2} {",
            "    @Override",
            "    public void ${2:method1}() {",
            "        // Implementation of method1",
            "    }",
            "",
            "    @Override",
            "    public void ${4:method2}() {",
            "        // Implementation of method2",
            "    }",
            "}"
        ],
        "description": "Interface Segregation Principle"
    },
    "Java Dependency Inversion Principle": {
        "prefix": "dependencyInversion",
        "body": [
            "public interface ${1:Service} {",
            "    void ${2:execute}();",
            "}",
            "",
            "public class ${3:ServiceImpl} implements ${1:Service} {",
            "    @Override",
            "    public void ${2:execute}() {",
            "        // Implementation",
            "    }",
            "}",
            "",
            "public class ${4:Client} {",
            "    private ${1:Service} ${5:service};",
            "",
            "    public ${4:Client}(${1:Service} ${5:service}) {",
            "        this.${5:service} = ${5:service};",
            "    }",
            "",
            "    public void ${6:perform}() {",
            "        ${5:service}.${2:execute}();",
            "    }",
            "}"
        ],
        "description": "Dependency Inversion Principle"
    },
    "Java Encapsulation": {
        "prefix": "encapsulation",
        "body": [
            "public class ${1:ClassName} {",
            "    private ${2:Type} ${3:variable};",
            "",
            "    public ${2:Type} get${3:Variable}() {",
            "        return ${3:variable};",
            "    }",
            "",
            "    public void set${3:Variable}(${2:Type} ${3:variable}) {",
            "        this.${3:variable} = ${3:variable};",
            "    }",
            "}"
        ],
        "description": "Encapsulation with getters and setters"
    },
    "Java Abstract Class and Extension": {
        "prefix": "javaAbstractClassExtension",
        "body": [
            "public class ${1:BaseClass} {",
            "    public void ${2:baseMethod}() {",
            "        // Base class method implementation",
            "    }",
            "}",
            "",
            "public class ${3:DerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:baseMethod}() {",
            "        // Derived class method implementation",
            "    }",
            "}"
        ],
        "description": "Java Abstract Class and Extension"
    },
    "Java Polymorphism": {
        "prefix": "polymorphism",
        "body": [
            "public class ${1:BaseClass} {",
            "    public void ${2:methodName}() {",
            "        // Base class method implementation",
            "    }",
            "}",
            "",
            "public class ${3:DerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:methodName}() {",
            "        // Derived class method implementation",
            "    }",
            "}",
            "",
            "public class ${4:AnotherDerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:methodName}() {",
            "        // Another derived class method implementation",
            "    }",
            "}"
        ],
        "description": "Polymorphism with method overriding"
    },
    "Java Abstraction": {
        "prefix": "abstraction",
        "body": [
            "public abstract class ${1:AbstractClass} {",
            "    public abstract void ${2:abstractMethod}();",
            "",
            "    public void ${3:concreteMethod}() {",
            "        // Concrete method implementation",
            "    }",
            "}",
            "",
            "public class ${4:ConcreteClass} extends ${1:AbstractClass} {",
            "    @Override",
            "    public void ${2:abstractMethod}() {",
            "        // Implementation of abstract method",
            "    }",
            "}"
        ],
        "description": "Abstraction with an abstract class"
    },
    "Java Encapsulation Private Fields": {
        "prefix": "privateFields",
        "body": [
            "public class ${1:ClassName} {",
            "    private ${2:Type} ${3:fieldName};",
            "",
            "    public ${2:Type} get${4:FieldName}() {",
            "        return ${3:fieldName};",
            "    }",
            "",
            "    public void set${4:FieldName}(${2:Type} ${3:fieldName}) {",
            "        this.${3:fieldName} = ${3:fieldName};",
            "    }",
            "}"
        ],
        "description": "Encapsulation with private fields and public methods"
    },
    "Java Class Composition": {
        "prefix": "classComposition",
        "body": [
            "public class ${1:ClassName} {",
            "    private ${2:DependencyClass} ${3:dependency};",
            "",
            "    public ${1:ClassName}(${2:DependencyClass} ${3:dependency}) {",
            "        this.${3:dependency} = ${3:dependency};",
            "}",
            "",
            "    public void ${4:useDependency}() {",
            "        ${3:dependency}.${5:dependencyMethod}();",
            "    }",
            "}"
        ],
        "description": "Class composition"
    },
    "Java Interface Implementation": {
        "prefix": "interfaceImplementation",
        "body": [
            "public interface ${1:InterfaceName} {",
            "    void ${2:methodName}();",
            "}",
            "",
            "public class ${3:ClassName} implements ${1:InterfaceName} {",
            "    @Override",
            "    public void ${2:methodName}() {",
            "        // Implementation of method",
            "    }",
            "}"
        ],
        "description": "Interface implementation"
    },
    "Java Abstract Class with Methods": {
        "prefix": "abstractClassMethods",
        "body": [
            "public abstract class ${1:AbstractClass} {",
            "    public abstract void ${2:abstractMethod}();",
            "",
            "    public void ${3:concreteMethod}() {",
            "        // Concrete method implementation",
            "    }",
            "}"
        ],
        "description": "Abstract class with abstract and concrete methods"
    },
    "Java Method Overloading": {
        "prefix": "methodOverloading",
        "body": [
            "public class ${1:ClassName} {",
            "    public void ${2:methodName}(${3:Type1} ${4:param1}) {",
            "        // Method implementation 1",
            "    }",
            "",
            "    public void ${2:methodName}(${5:Type2} ${6:param2}) {",
            "        // Method implementation 2",
            "    }",
            "}"
        ],
        "description": "Method overloading"
    },
    "Java Static Method": {
        "prefix": "staticMethod",
        "body": [
            "public class ${1:ClassName} {",
            "    public static ${2:returnType} ${3:methodName}(${4:parameterType} ${5:parameter}) {",
            "        // Static method implementation",
            "    }",
            "}"
        ],
        "description": "Static method"
    },
    "Java Factory Method Pattern": {
        "prefix": "factoryMethod",
        "body": [
            "public abstract class ${1:Product} {",
            "    public abstract void ${2:method}();",
            "}",
            "",
            "public class ${3:ConcreteProduct} extends ${1:Product} {",
            "    @Override",
            "    public void ${2:method}() {",
            "        // Implementation",
            "    }",
            "}",
            "",
            "public abstract class ${4:Creator} {",
            "    public abstract ${1:Product} ${5:createProduct}();",
            "}",
            "",
            "public class ${6:ConcreteCreator} extends ${4:Creator} {",
            "    @Override",
            "    public ${1:Product} ${5:createProduct}() {",
            "        return new ${3:ConcreteProduct}();",
            "    }",
            "}"
        ],
        "description": "Factory Method Pattern"
    },
    "Java Builder Pattern": {
        "prefix": "builderPattern",
        "body": [
            "public class ${1:Product} {",
            "    private ${2:Type1} ${3:field1};",
            "    private ${4:Type2} ${5:field2};",
            "",
            "    private ${1:Product}(${6:Builder} builder) {",
            "        this.${3:field1} = builder.${3:field1};",
            "        this.${5:field2} = builder.${5:field2};",
            "    }",
            "",
            "    public static class ${6:Builder} {",
            "        private ${2:Type1} ${3:field1};",
            "        private ${4:Type2} ${5:field2};",
            "",
            "        public ${6:Builder} set${7:Field1}(${2:Type1} ${3:field1}) {",
            "            this.${3:field1} = ${3:field1};",
            "            return this;",
            "        }",
            "",
            "        public ${6:Builder} set${8:Field2}(${4:Type2} ${5:field2}) {",
            "            this.${5:field2} = ${5:field2};",
            "            return this;",
            "        }",
            "",
            "        public ${1:Product} build() {",
            "            return new ${1:Product}(this);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Builder Pattern"
    },
    "Java Singleton Pattern": {
        "prefix": "singletonPattern",
        "body": [
            "public class ${1:Singleton} {",
            "    private static ${1:Singleton} instance;",
            "",
            "    private ${1:Singleton}() {",
            "        // Private constructor to prevent instantiation",
            "    }",
            "",
            "    public static ${1:Singleton} getInstance() {",
            "        if (instance == null) {",
            "            instance = new ${1:Singleton}();",
            "        }",
            "        return instance;",
            "    }",
            "}"
        ],
        "description": "Singleton Pattern"
    },
    "Java Adapter Pattern": {
        "prefix": "adapterPattern",
        "body": [
            "public interface ${1:Target} {",
            "    void ${2:request}();",
            "}",
            "",
            "public class ${3:Adaptee} {",
            "    public void ${4:specificRequest}() {",
            "        // Specific request implementation",
            "    }",
            "}",
            "",
            "public class ${5:Adapter} implements ${1:Target} {",
            "    private ${3:Adaptee} adaptee;",
            "",
            "    public ${5:Adapter}(${3:Adaptee} adaptee) {",
            "        this.adaptee = adaptee;",
            "    }",
            "",
            "    @Override",
            "    public void ${2:request}() {",
            "        adaptee.${4:specificRequest}();",
            "    }",
            "}"
        ],
        "description": "Adapter Pattern"
    },
    "Java Observer Pattern": {
        "prefix": "observerPattern",
        "body": [
            "public interface ${1:Observer} {",
            "    void ${2:update}(${3:Observable} ${4:observable});",
            "}",
            "",
            "public class ${3:Observable} {",
            "    private List<${1:Observer}> observers = new ArrayList<>();",
            "",
            "    public void ${5:addObserver}(${1:Observer} observer) {",
            "        observers.add(observer);",
            "    }",
            "",
            "    public void ${6:removeObserver}(${1:Observer} observer) {",
            "        observers.remove(observer);",
            "    }",
            "",
            "    public void ${7:notifyObservers}() {",
            "        for (${1:Observer} observer : observers) {",
            "            observer.${2:update}(this);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Observer Pattern"
    },
    "Java Strategy Pattern": {
        "prefix": "strategyPattern",
        "body": [
            "public interface ${1:Strategy} {",
            "    void ${2:execute}();",
            "}",
            "",
            "public class ${3:ConcreteStrategyA} implements ${1:Strategy} {",
            "    @Override",
            "    public void ${2:execute}() {",
            "        // Implementation of strategy A",
            "    }",
            "}",
            "",
            "public class ${4:ConcreteStrategyB} implements ${1:Strategy} {",
            "    @Override",
            "    public void ${2:execute}() {",
            "        // Implementation of strategy B",
            "    }",
            "}",
            "",
            "public class ${5:Context} {",
            "    private ${1:Strategy} strategy;",
            "",
            "    public void ${6:setStrategy}(${1:Strategy} strategy) {",
            "        this.strategy = strategy;",
            "    }",
            "",
            "    public void ${7:executeStrategy}() {",
            "        strategy.${2:execute}();",
            "    }",
            "}"
        ],
        "description": "Strategy Pattern"
    },
    "Java Command Pattern": {
        "prefix": "commandPattern",
        "body": [
            "public interface ${1:Command} {",
            "    void ${2:execute}();",
            "}",
            "",
            "public class ${3:ConcreteCommand} implements ${1:Command} {",
            "    private ${4:Receiver} receiver;",
            "",
            "    public ${3:ConcreteCommand}(${4:Receiver} receiver) {",
            "        this.receiver = receiver;",
            "    }",
            "",
            "    @Override",
            "    public void ${2:execute}() {",
            "        receiver.${5:action}();",
            "    }",
            "}",
            "",
            "public class ${4:Receiver} {",
            "    public void ${5:action}() {",
            "        // Action implementation",
            "    }",
            "}",
            "",
            "public class ${6:Invoker} {",
            "    private ${1:Command} command;",
            "",
            "    public void ${7:setCommand}(${1:Command} command) {",
            "        this.command = command;",
            "    }",
            "",
            "    public void ${8:invoke}() {",
            "        command.${2:execute}();",
            "    }",
            "}"
        ],
        "description": "Command Pattern"
    },
    "Java Template Method Pattern": {
        "prefix": "templateMethodPattern",
        "body": [
            "public abstract class ${1:AbstractClass} {",
            "    public final void ${2:templateMethod}() {",
            "        ${3:stepOne}();",
            "        ${4:stepTwo}();",
            "        ${5:stepThree}();",
            "    }",
            "",
            "    protected abstract void ${3:stepOne}();",
            "    protected abstract void ${4:stepTwo}();",
            "    protected void ${5:stepThree}() {",
            "        // Default implementation (optional)",
            "    }",
            "}",
            "",
            "public class ${6:ConcreteClass} extends ${1:AbstractClass} {",
            "    @Override",
            "    protected void ${3:stepOne}() {",
            "        // Implementation of step one",
            "    }",
            "",
            "    @Override",
            "    protected void ${4:stepTwo}() {",
            "        // Implementation of step two",
            "    }",
            "}"
        ],
        "description": "Template Method Pattern"
    },
    "Java Chain of Responsibility Pattern": {
        "prefix": "chainOfResponsibilityPattern",
        "body": [
            "public abstract class ${1:Handler} {",
            "    protected ${1:Handler} ${2:nextHandler};",
            "",
            "    public void ${3:setNextHandler}(${1:Handler} handler) {",
            "        this.${2:nextHandler} = handler;",
            "    }",
            "",
            "    public void ${4:handleRequest}(${5:Request} request) {",
            "        if (${6:canHandleRequest}(request)) {",
            "            ${7:processRequest}(request);",
            "        } else if (${2:nextHandler} != null) {",
            "            ${2:nextHandler}.${4:handleRequest}(request);",
            "        }",
            "    }",
            "",
            "    protected abstract boolean ${6:canHandleRequest}(${5:Request} request);",
            "    protected abstract void ${7:processRequest}(${5:Request} request);",
            "}",
            "",
            "public class ${8:ConcreteHandler1} extends ${1:Handler} {",
            "    @Override",
            "    protected boolean ${6:canHandleRequest}(${5:Request} request) {",
            "        // Check if this handler can handle the request",
            "        return ${9:condition};",
            "    }",
            "",
            "    @Override",
            "    protected void ${7:processRequest}(${5:Request} request) {",
            "        // Process the request",
            "    }",
            "}",
            "",
            "public class ${10:ConcreteHandler2} extends ${1:Handler} {",
            "    @Override",
            "    protected boolean ${6:canHandleRequest}(${5:Request} request) {",
            "        // Check if this handler can handle the request",
            "        return ${11:condition};",
            "    }",
            "",
            "    @Override",
            "    protected void ${7:processRequest}(${5:Request} request) {",
            "        // Process the request",
            "    }",
            "}"
        ],
        "description": "Chain of Responsibility Pattern"
    },
    "Java Switch Statement": {
        "prefix": "switch",
        "body": [
            "switch (${1:variable}) {",
            "    case ${2:value1}:",
            "        ${3:// code block}",
            "        break;",
            "    case ${4:value2}:",
            "        ${5:// code block}",
            "        break;",
            "    default:",
            "        ${6:// default code block}",
            "}"
        ],
        "description": "Switch statement"
    },
    "Java While Loop": {
        "prefix": "while",
        "body": [
            "while (${1:condition}) {",
            "    ${2:// code block}",
            "}"
        ],
        "description": "While loop"
    },
    "Java Do-While Loop": {
        "prefix": "doWhile",
        "body": [
            "do {",
            "    ${1:// code block}",
            "} while (${2:condition});"
        ],
        "description": "Do-while loop"
    },
    "Java Synchronized Method": {
        "prefix": "synchronizedMethod",
        "body": [
            "public synchronized ${1:void} ${2:methodName}(${3:parameters}) {",
            "    ${4:// method body}",
            "}"
        ],
        "description": "Synchronized method"
    },
    "Java Enum": {
        "prefix": "enum",
        "body": [
            "public enum ${1:EnumName} {",
            "    ${2:CONSTANT1},",
            "    ${3:CONSTANT2},",
            "    ${4:CONSTANT3};",
            "}"
        ],
        "description": "Enum definition"
    },
    "Java Try-With-Resources": {
        "prefix": "tryWithResources",
        "body": [
            "try (${1:ResourceType} ${2:resource} = new ${1:ResourceType}(${3:parameters})) {",
            "    ${4:// code block}",
            "} catch (${5:ExceptionType} ${6:e}) {",
            "    ${7:// exception handling}",
            "}"
        ],
        "description": "Try-with-resources statement"
    },
    "Java Lambda Expression": {
        "prefix": "lambda",
        "body": [
            "${1:Type} ${2:variable} = (${3:parameters}) -> {",
            "    ${4:// lambda body}",
            "};"
        ],
        "description": "Lambda expression"
    },
    "Java Stream API": {
        "prefix": "stream",
        "body": [
            "${1:collection}.stream()",
            "    .${2:filter}(${3:condition})",
            "    .${4:forEach}(${5:action});"
        ],
        "description": "Stream API usage"
    },
    "Java Try-Catch Block": {
        "prefix": "tryCatch",
        "body": [
            "try {",
            "    ${1:// code block}",
            "} catch (${2:ExceptionType} ${3:e}) {",
            "    ${4:// exception handling}",
            "}"
        ],
        "description": "Try-catch block"
    },
    "Java Try-Catch-Finally Block": {
        "prefix": "tryCatchFinally",
        "body": [
            "try {",
            "    ${1:// code block}",
            "} catch (${2:ExceptionType} ${3:e}) {",
            "    ${4:// exception handling}",
            "} finally {",
            "    ${5:// cleanup code}",
            "}"
        ],
        "description": "Try-catch-finally block"
    },
    "Java Throw Exception": {
        "prefix": "throw",
        "body": [
            "throw new ${1:ExceptionType}(${2:message});"
        ],
        "description": "Throw an exception"
    },
    "Java Custom Exception Class": {
        "prefix": "customException",
        "body": [
            "public class ${1:CustomExceptionName} extends ${2:Exception} {",
            "    public ${1:CustomExceptionName}(${3:String message}) {",
            "        super(message);",
            "    }",
            "}"
        ],
        "description": "Custom exception class"
    },
    "Java Multi-Catch Block": {
        "prefix": "multiCatch",
        "body": [
            "try {",
            "    ${1:// code block}",
            "} catch (${2:ExceptionType1} | ${3:ExceptionType2} ${4:e}) {",
            "    ${5:// exception handling}",
            "}"
        ],
        "description": "Multi-catch block"
    },
    "Java Iterator": {
        "prefix": "iterator",
        "body": [
            "Iterator<${1:Type}> ${2:iterator} = ${3:collection}.iterator();",
            "while (${2:iterator}.hasNext()) {",
            "    ${1:Type} ${4:element} = ${2:iterator}.next();",
            "    ${5:// code block}",
            "}"
        ],
        "description": "Iterate with Iterator"
    },
    "Java Stream API Filter": {
        "prefix": "streamFilter",
        "body": [
            "${1:collection}.stream()",
            "    .filter(${2:condition})",
            "    .collect(Collectors.toList());"
        ],
        "description": "Stream API for filtering"
    },
    "Java Stream API Map": {
        "prefix": "streamMap",
        "body": [
            "${1:collection}.stream()",
            "    .map(${2:mapper})",
            "    .collect(Collectors.toList());"
        ],
        "description": "Stream API for mapping"
    },
    "Get Input With Validation": {
        "prefix": "getInputWithValidation",
        "body": [
            "public static String getInputWithValidation(Scanner scanner, String prompt, Function<String, Boolean> validator) {",
            "    String input;",
            "    try {",
            "        do {",
            "            System.out.print(prompt);",
            "            input = scanner.nextLine();",
            "        } while (!validator.apply(input));",
            "    } catch (NoSuchElementException | IllegalStateException e) {",
            "        System.out.println(\"An error occurred while reading input: \" + e.getMessage());",
            "        input = \"\";",
            "    }",
            "    return input;",
            "}"
        ],
        "description": "Gets input from the user with validation using a provided validator function."
    },
    "Validate Numeric Input Within Range": {
        "prefix": "validateNumericInputWithinRange",
        "body": [
            "public static boolean validateNumericInputWithinRange(String input, int minValue, int maxValue) {",
            "    try {",
            "        int value = Integer.parseInt(input);",
            "        if (value < minValue || value > maxValue) {",
            "            System.out.println(\"Please enter a valid value between \" + minValue + \" and \" + maxValue + \".\");",
            "            return false;",
            "        }",
            "        return true;",
            "    } catch (NumberFormatException e) {",
            "        System.out.println(\"Invalid input. Please enter a numeric value.\");",
            "        return false;",
            "    }",
            "}"
        ],
        "description": "Validates if a given input is numeric and within a specified range."
    },
    "Validate NonEmpty Input": {
        "prefix": "validateNonEmptyInput",
        "body": [
            "public static boolean validateNonEmptyInput(String input) {",
            "    if (input.trim().isEmpty()) {",
            "        System.out.println(\"Invalid input. Please enter a non-empty value.\");",
            "        return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Validates if a given input is not empty."
    },
    "Add Value To Total And Increment Count": {
        "prefix": "addValueToTotalAndIncrementCount",
        "body": [
            "public void addValueToTotalAndIncrementCount(int value) {",
            "    this.total += value;",
            "    this.count++;",
            "}"
        ],
        "description": "Adds a value to a running total and increments a count."
    },
    "Calculate Average": {
        "prefix": "calculateAverage",
        "body": [
            "public double calculateAverage() {",
            "    if (count == 0) {",
            "        return 0;",
            "    }",
            "    return (double) total / count;",
            "}"
        ],
        "description": "Calculates the average of accumulated values."
    },
    "Determine Grade From Average": {
        "prefix": "determineGradeFromAverage",
        "body": [
            "public char determineGradeFromAverage() {",
            "    double average = calculateAverage();",
            "    if (average >= 90)",
            "        return 'A';",
            "    if (average >= 80)",
            "        return 'B';",
            "    if (average >= 70)",
            "        return 'C';",
            "    if (average >= 60)",
            "        return 'D';",
            "    return 'F';",
            "}"
        ],
        "description": "Determines a letter grade based on a calculated average."
    },
    "Display Results": {
        "prefix": "displayResults",
        "body": [
            "public void displayResults() {",
            "    double average = calculateAverage();",
            "    char grade = determineGradeFromAverage();",
            "    System.out.println(\"Name: \" + getName());",
            "    System.out.printf(\"Average: %.2f%n\", average);",
            "    System.out.println(\"Grade: \" + grade);",
            "}"
        ],
        "description": "Displays results, including name, average, and grade."
    },
    "Get Values From User Until Stop Word": {
        "prefix": "getValuesFromUserUntilStopWord",
        "body": [
            "public void getValuesFromUserUntilStopWord(Scanner scanner, String stopWord, int minValue, int maxValue) {",
            "    while (true) {",
            "        System.out.print(\"Enter value (or type '\" + stopWord + \"' to finish): \");",
            "        String input = scanner.nextLine();",
            "        if (input.equalsIgnoreCase(stopWord)) {",
            "            break;",
            "        }",
            "        if (validateNumericInputWithinRange(input, minValue, maxValue)) {",
            "            addValueToTotalAndIncrementCount(Integer.parseInt(input));",
            "        }",
            "    }",
            "}"
        ],
        "description": "Gets numeric values from the user until a stop word is entered."
    },
    "JavaDoc Basic Example": {
        "prefix": "javadocBasic",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "Try-With-Resources": {
        "prefix": "tryWithResources",
        "body": [
            "try (${1:ResourceType} ${2:resource} = new ${1:ResourceType}(${3:parameters})) {",
            "    ${4:// code block}",
            "} catch (${5:ExceptionType} ${6:e}) {",
            "    ${7:// exception handling}",
            "}"
        ],
        "description": "Demonstrates the use of try-with-resources for automatic resource management."
    },
    "Optional Usage": {
        "prefix": "optionalUsage",
        "body": [
            "Optional<String> optionalString = Optional.ofNullable(${1:value});",
            "",
            "if (optionalString.isPresent()) {",
            "    String value = optionalString.get();",
            "    // Use the value",
            "} else {",
            "    // Handle the case where the value is absent",
            "}",
            "",
            "String defaultValue = optionalString.orElse(${2:default});",
            "",
            "String valueIfPresent = optionalString.orElseThrow(${3:exceptionSupplier});"
        ],
        "description": "Best practices for using `Optional` to handle null values effectively."
    },
    "Override-Equivalent Methods": {
        "prefix": "overrideEquivalent",
        "body": [
            "public class ${1:BaseClass} {",
            "    public void ${2:baseMethod}() {",
            "        // Base implementation",
            "    }",
            "}",
            "",
            "public class ${3:DerivedClass} extends ${1:BaseClass} {",
            "    @Override",
            "    public void ${2:baseMethod}() {",
            "        // Derived implementation",
            "    }",
            "}",
            "",
            "public class ${4:AnotherDerivedClass} extends ${1:BaseClass} {",
            "    public void ${2:baseMethod}(${5:Type} ${6:param}) {",
            "        // Overloaded implementation",
            "    }",
            "}"
        ],
        "description": "Example of inheritance with override-equivalent methods."
    },
    "Enum with Methods": {
        "prefix": "enumWithMethods",
        "body": [
            "public enum ${1:EnumName} {",
            "    ${2:CONSTANT1},",
            "    ${3:CONSTANT2},",
            "    ${4:CONSTANT3};",
            "",
            "    public void ${5:methodName}() {",
            "        // Method implementation",
            "    }",
            "",
            "    public static void main(String[] args) {",
            "        for (${1:EnumName} value : ${1:EnumName}.values()) {",
            "            value.${5:methodName}();",
            "        }",
            "    }",
            "}"
        ],
        "description": "Enum that includes methods and demonstrates iterating over constants."
    },
    "Synchronized Method": {
        "prefix": "synchronizedMethod",
        "body": [
            "public synchronized ${1:void} ${2:methodName}(${3:parameters}) {",
            "    ${4:// method body}",
            "}"
        ],
        "description": "Use of synchronized keyword to control access to a method."
    },
    "Static Block Initialization": {
        "prefix": "staticBlock",
        "body": [
            "public class ${1:ClassName} {",
            "    static {",
            "        ${2:// Initialization code}",
            "    }",
            "}"
        ],
        "description": "Demonstrates the use of static blocks for initializing static variables."
    },
    "LinkedHashMap with Access Order": {
        "prefix": "linkedHashMapAccessOrder",
        "body": [
            "Map<${1:KeyType}, ${2:ValueType}> ${3:mapName} = new LinkedHashMap<>();",
            "${3:mapName}.put(${4:key1}, ${5:value1});",
            "${3:mapName}.put(${6:key2}, ${7:value2});",
            "${3:mapName}.put(${8:key3}, ${9:value3});",
            "System.out.println(${3:mapName}); // Output: {key1=value1, key2=value2, key3=value3}"
        ],
        "description": "Demonstrates the creation of a `LinkedHashMap` that maintains access order."
    },
    "ArrayList Reversed View": {
        "prefix": "arrayListReversed",
        "body": [
            "List<${1:Type}> ${2:listName} = new ArrayList<>(Arrays.asList(${3:elements}));",
            "Collections.reverse(${2:listName});",
            "System.out.println(${2:listName}); // Output: Reversed list"
        ],
        "description": "Demonstrates creating a reversed view of an `ArrayList`."
    },
    "Unmodifiable Collections": {
        "prefix": "unmodifiableCollections",
        "body": [
            "List<String> originalList = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));",
            "List<String> unmodifiableList = Collections.unmodifiableList(originalList);",
            "",
            "Set<String> originalSet = new HashSet<>(Arrays.asList(\"x\", \"y\", \"z\"));",
            "Set<String> unmodifiableSet = Collections.unmodifiableSet(originalSet);",
            "",
            "Map<String, Integer> originalMap = new HashMap<>();",
            "originalMap.put(\"key1\", 1);",
            "originalMap.put(\"key2\", 2);",
            "Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(originalMap);"
        ],
        "description": "Creating unmodifiable views of various collections."
    },
    "Stream API Enhancements": {
        "prefix": "streamApiEnhancements",
        "body": [
            "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);",
            "",
            "// Filtering",
            "List<Integer> evenNumbers = numbers.stream()",
            "    .filter(n -> n % 2 == 0)",
            "    .collect(Collectors.toList());",
            "",
            "// Mapping",
            "List<String> numberStrings = numbers.stream()",
            "    .map(String::valueOf)",
            "    .collect(Collectors.toList());",
            "",
            "// Reducing",
            "int sum = numbers.stream()",
            "    .reduce(0, Integer::sum);"
        ],
        "description": "Demonstrates advanced usage of the Stream API for collections."
    },
    "JavaDoc Compliance": {
        "prefix": "javadocCompliance",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "JavaDoc for Enum": {
        "prefix": "javadocEnum",
        "body": [
            "/**",
            " * This is an enum type with constants representing different states.",
            " */",
            "public enum ${1:EnumName} {",
            "    /**",
            "     * Constant representing the first state.",
            "     */",
            "    ${2:CONSTANT1},",
            "    /**",
            "     * Constant representing the second state.",
            "     */",
            "    ${3:CONSTANT2},",
            "    /**",
            "     * Constant representing the third state.",
            "     */",
            "    ${4:CONSTANT3};",
            "}"
        ],
        "description": "JavaDoc for an enum type with details on each constant."
    },
    "Java Language Specification Compliance": {
        "prefix": "javaLanguageSpecificationCompliance",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "Java JVM Specification Compliance": {
        "prefix": "javaJVMSpecificationCompliance",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "Java Sequenced Collections Usage": {
        "prefix": "javaSequencedCollectionsUsage",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "Java Collections Framework Enhancements": {
        "prefix": "javaCollectionsFrameworkEnhancements",
        "body": [
            "/**",
            " * This is a basic Java class with a main method.",
            " */",
            "public class ${1:ClassName} {",
            "    /**",
            "     * Main method of the class.",
            "     *",
            "     * @param args Command line arguments.",
            "     */",
            "    public static void main(String[] args) {",
            "        $0 //main method body",
            "    }",
            "}"
        ],
        "description": "Basic JavaDoc for a class and its methods."
    },
    "Java Core Libraries Utilization": {
        "tryWithResources": {
            "description": "Demonstrates the use of try-with-resources for automatic resource management.",
            "body": "try (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n}"
        },
        "optionalUsage": {
            "description": "Best practices for using `Optional` to handle null values effectively.",
            "body": "Optional<String> optionalName = Optional.ofNullable(getName());\noptionalName.ifPresent(name -> System.out.println(name));"
        },
        "JVM Specification Compliance": {
            "synchronizedMethod": {
                "description": "Use of synchronized keyword to control access to a method.",
                "body": "public synchronized void increment() {\n    count++;\n}"
            },
            "staticBlock": {
                "description": "Demonstrates the use of static blocks for initializing static variables.",
                "body": "class Example {\n    static int value;\n    static {\n        value = 10;\n    }\n}"
            }
        },
        "Sequenced Collections Usage": {
            "linkedHashMapAccessOrder": {
                "description": "Demonstrates the creation of a `LinkedHashMap` that maintains access order.",
                "body": "LinkedHashMap<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.get(\"A\"); // Access A\n// Iterating will show A first due to access order."
            },
            "arrayListReversed": {
                "description": "Demonstrates creating a reversed view of an `ArrayList`.",
                "body": "ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\nCollections.reverse(list);\nSystem.out.println(list); // Output: [5, 4, 3, 2, 1]"
            }
        }
    },
    "Java ArrayList Full": {
        "prefix": "fullArrayList",
        "body": [
            "import java.util.ArrayList;",
            "import java.util.List;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        List<${2:Type}> ${3:listName} = new ArrayList<>();",
            "        ${3:listName}.add(${4:element}); // Add element",
            "        ${2:Type} element = ${3:listName}.get(0); // Get element",
            "        ${3:listName}.set(0, ${4:newElement}); // Set element at index",
            "        ${3:listName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:listName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:listName}.size(); // Get the size of the list",
            "        ${3:listName}.clear(); // Clear the list",
            "    }",
            "}"
        ],
        "description": "Full ArrayList initialization and common methods"
    },
    "Java Stack Full": {
        "prefix": "fullStack",
        "body": [
            "import java.util.Stack;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Stack<${2:Type}> ${3:stackName} = new Stack<>();",
            "        ${3:stackName}.push(${4:element}); // Push element onto the stack",
            "        ${2:Type} topElement = ${3:stackName}.peek(); // Peek at the top element of the stack",
            "        ${2:Type} poppedElement = ${3:stackName}.pop(); // Pop element from the stack",
            "        boolean isEmpty = ${3:stackName}.isEmpty(); // Check if the stack is empty",
            "        int size = ${3:stackName}.size(); // Get the size of the stack",
            "        ${3:stackName}.clear(); // Clear the stack",
            "    }",
            "}"
        ],
        "description": "Full Stack initialization and common methods"
    },
    "Java HashSet Full": {
        "prefix": "fullHashSet",
        "body": [
            "import java.util.HashSet;",
            "import java.util.Set;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Set<${2:Type}> ${3:setName} = new HashSet<>();",
            "        ${3:setName}.add(${4:element}); // Add element",
            "        ${3:setName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:setName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:setName}.size(); // Get the size of the set",
            "        ${3:setName}.clear(); // Clear the set",
            "    }",
            "}"
        ],
        "description": "Full HashSet initialization and common methods"
    },
    "Java HashMap Full": {
        "prefix": "fullHashMap",
        "body": [
            "import java.util.HashMap;",
            "import java.util.Map;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new HashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full HashMap initialization and common methods"
    },
    "Java LinkedHashMap Full": {
        "prefix": "fullLinkedHashMap",
        "body": [
            "import java.util.LinkedHashMap;",
            "import java.util.Map;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new LinkedHashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full LinkedHashMap initialization and common methods"
    },
    "Java TreeMap Full": {
        "prefix": "fullTreeMap",
        "body": [
            "import java.util.TreeMap;",
            "import java.util.Map;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new TreeMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full TreeMap initialization and common methods"
    },
    "Java PriorityQueue Full": {
        "prefix": "fullPriorityQueue",
        "body": [
            "import java.util.PriorityQueue;",
            "import java.util.Queue;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Queue<${2:Type}> ${3:queueName} = new PriorityQueue<>();",
            "        ${3:queueName}.add(${4:element}); // Add element",
            "        ${2:Type} headElement = ${3:queueName}.peek(); // Peek at the head element of the queue",
            "        ${2:Type} removedElement = ${3:queueName}.poll(); // Remove and return the head element",
            "        boolean isEmpty = ${3:queueName}.isEmpty(); // Check if the queue is empty",
            "        int size = ${3:queueName}.size(); // Get the size of the queue",
            "        ${3:queueName}.clear(); // Clear the queue",
            "    }",
            "}"
        ],
        "description": "Full PriorityQueue initialization and common methods"
    },
    "Java Deque Full": {
        "prefix": "fullDeque",
        "body": [
            "import java.util.Deque;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Deque<${2:Type}> ${3:dequeName} = new LinkedList<>();",
            "        ${3:dequeName}.addFirst(${4:element}); // Add element to the front",
            "        ${3:dequeName}.addLast(${4:element}); // Add element to the end",
            "        ${2:Type} firstElement = ${3:dequeName}.getFirst(); // Get the first element",
            "        ${2:Type} lastElement = ${3:dequeName}.getLast(); // Get the last element",
            "        ${2:Type} removedFirst = ${3:dequeName}.removeFirst(); // Remove and return the first element",
            "        ${2:Type} removedLast = ${3:dequeName}.removeLast(); // Remove and return the last element",
            "        boolean isEmpty = ${3:dequeName}.isEmpty(); // Check if the deque is empty",
            "        int size = ${3:dequeName}.size(); // Get the size of the deque",
            "        ${3:dequeName}.clear(); // Clear the deque",
            "    }",
            "}"
        ],
        "description": "Full Deque initialization and common methods"
    },
    "Java ArrayDeque Full": {
        "prefix": "fullArrayDeque",
        "body": [
            "import java.util.ArrayDeque;",
            "import java.util.Deque;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Deque<${2:Type}> ${3:dequeName} = new ArrayDeque<>();",
            "        ${3:dequeName}.addFirst(${4:element}); // Add element to the front",
            "        ${3:dequeName}.addLast(${4:element}); // Add element to the end",
            "        ${2:Type} firstElement = ${3:dequeName}.getFirst(); // Get the first element",
            "        ${2:Type} lastElement = ${3:dequeName}.getLast(); // Get the last element",
            "        ${2:Type} removedFirst = ${3:dequeName}.removeFirst(); // Remove and return the first element",
            "        ${2:Type} removedLast = ${3:dequeName}.removeLast(); // Remove and return the last element",
            "        boolean isEmpty = ${3:dequeName}.isEmpty(); // Check if the deque is empty",
            "        int size = ${3:dequeName}.size(); // Get the size of the deque",
            "        ${3:dequeName}.clear(); // Clear the deque",
            "    }",
            "}"
        ],
        "description": "Full ArrayDeque initialization and common methods"
    },
    "Java LinkedList Full": {
        "prefix": "fullLinkedList",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.List;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        List<${2:Type}> ${3:listName} = new LinkedList<>();",
            "        ${3:listName}.add(${4:element}); // Add element",
            "        ${2:Type} element = ${3:listName}.get(0); // Get element",
            "        ${3:listName}.set(0, ${4:newElement}); // Set element at index",
            "        ${3:listName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:listName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:listName}.size(); // Get the size of the list",
            "        ${3:listName}.clear(); // Clear the list",
            "    }",
            "}"
        ],
        "description": "Full LinkedList initialization and common methods"
    },
    "Java Vector Full": {
        "prefix": "fullVector",
        "body": [
            "import java.util.Vector;",
            "import java.util.List;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        List<${2:Type}> ${3:listName} = new Vector<>();",
            "        ${3:listName}.add(${4:element}); // Add element",
            "        ${2:Type} element = ${3:listName}.get(0); // Get element",
            "        ${3:listName}.set(0, ${4:newElement}); // Set element at index",
            "        ${3:listName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:listName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:listName}.size(); // Get the size of the list",
            "        ${3:listName}.clear(); // Clear the list",
            "    }",
            "}"
        ],
        "description": "Full Vector initialization and common methods"
    },
    "Java Queue Full": {
        "prefix": "fullQueue",
        "body": [
            "import java.util.Queue;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Queue<${2:Type}> ${3:queueName} = new LinkedList<>();",
            "        ${3:queueName}.add(${4:element}); // Add element",
            "        ${2:Type} headElement = ${3:queueName}.peek(); // Peek at the head element of the queue",
            "        ${2:Type} removedElement = ${3:queueName}.poll(); // Remove and return the head element",
            "        boolean isEmpty = ${3:queueName}.isEmpty(); // Check if the queue is empty",
            "        int size = ${3:queueName}.size(); // Get the size of the queue",
            "        ${3:queueName}.clear(); // Clear the queue",
            "    }",
            "}"
        ],
        "description": "Full Queue initialization and common methods"
    },
    "Java LinkedListStack Full": {
        "prefix": "fullLinkedListStack",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.Stack;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Stack<${2:Type}> ${3:stackName} = new Stack<>();",
            "        ${3:stackName}.push(${4:element}); // Push element onto the stack",
            "        ${2:Type} topElement = ${3:stackName}.peek(); // Peek at the top element of the stack",
            "        ${2:Type} poppedElement = ${3:stackName}.pop(); // Pop element from the stack",
            "        boolean isEmpty = ${3:stackName}.isEmpty(); // Check if the stack is empty",
            "        int size = ${3:stackName}.size(); // Get the size of the stack",
            "        ${3:stackName}.clear(); // Clear the stack",
            "    }",
            "}"
        ],
        "description": "Full LinkedListStack initialization and common methods"
    },
    "Java LinkedListQueue Full": {
        "prefix": "fullLinkedListQueue",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.Queue;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Queue<${2:Type}> ${3:queueName} = new LinkedList<>();",
            "        ${3:queueName}.add(${4:element}); // Add element",
            "        ${2:Type} headElement = ${3:queueName}.peek(); // Peek at the head element of the queue",
            "        ${2:Type} removedElement = ${3:queueName}.poll(); // Remove and return the head element",
            "        boolean isEmpty = ${3:queueName}.isEmpty(); // Check if the queue is empty",
            "        int size = ${3:queueName}.size(); // Get the size of the queue",
            "        ${3:queueName}.clear(); // Clear the queue",
            "    }",
            "}"
        ],
        "description": "Full LinkedListQueue initialization and common methods"
    },
    "Java LinkedListDeque Full": {
        "prefix": "fullLinkedListDeque",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.Deque;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Deque<${2:Type}> ${3:dequeName} = new LinkedList<>();",
            "        ${3:dequeName}.addFirst(${4:element}); // Add element to the front",
            "        ${3:dequeName}.addLast(${4:element}); // Add element to the end",
            "        ${2:Type} firstElement = ${3:dequeName}.getFirst(); // Get the first element",
            "        ${2:Type} lastElement = ${3:dequeName}.getLast(); // Get the last element",
            "        ${2:Type} removedFirst = ${3:dequeName}.removeFirst(); // Remove and return the first element",
            "        ${2:Type} removedLast = ${3:dequeName}.removeLast(); // Remove and return the last element",
            "        boolean isEmpty = ${3:dequeName}.isEmpty(); // Check if the deque is empty",
            "        int size = ${3:dequeName}.size(); // Get the size of the deque",
            "        ${3:dequeName}.clear(); // Clear the deque",
            "    }",
            "}"
        ],
        "description": "Full LinkedListDeque initialization and common methods"
    },
    "Java LinkedListArrayListFull": {
        "prefix": "fullLinkedListArrayList",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.ArrayList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        List<${2:Type}> ${3:listName} = new LinkedList<>();",
            "        ${3:listName}.add(${4:element}); // Add element",
            "        ${2:Type} element = ${3:listName}.get(0); // Get element",
            "        ${3:listName}.set(0, ${4:newElement}); // Set element at index",
            "        ${3:listName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:listName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:listName}.size(); // Get the size of the list",
            "        ${3:listName}.clear(); // Clear the list",
            "    }",
            "}"
        ],
        "description": "Full LinkedListArrayList initialization and common methods"
    },
    "Java ArrayListLinkedListFull": {
        "prefix": "fullArrayListLinkedList",
        "body": [
            "import java.util.ArrayList;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        List<${2:Type}> ${3:listName} = new ArrayList<>();",
            "        ${3:listName}.add(${4:element}); // Add element",
            "        ${2:Type} element = ${3:listName}.get(0); // Get element",
            "        ${3:listName}.set(0, ${4:newElement}); // Set element at index",
            "        ${3:listName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:listName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:listName}.size(); // Get the size of the list",
            "        ${3:listName}.clear(); // Clear the list",
            "    }",
            "}"
        ],
        "description": "Full ArrayListLinkedList initialization and common methods"
    },
    "Java LinkedListHashSetFull": {
        "prefix": "fullLinkedListHashSet",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.HashSet;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Set<${2:Type}> ${3:setName} = new HashSet<>();",
            "        ${3:setName}.add(${4:element}); // Add element",
            "        ${3:setName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:setName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:setName}.size(); // Get the size of the set",
            "        ${3:setName}.clear(); // Clear the set",
            "    }",
            "}"
        ],
        "description": "Full LinkedListHashSet initialization and common methods"
    },
    "Java HashSetLinkedListFull": {
        "prefix": "fullHashSetLinkedList",
        "body": [
            "import java.util.HashSet;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Set<${2:Type}> ${3:setName} = new HashSet<>();",
            "        ${3:setName}.add(${4:element}); // Add element",
            "        ${3:setName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:setName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:setName}.size(); // Get the size of the set",
            "        ${3:setName}.clear(); // Clear the set",
            "    }",
            "}"
        ],
        "description": "Full HashSetLinkedList initialization and common methods"
    },
    "Java HashSetArrayListFull": {
        "prefix": "fullHashSetArrayList",
        "body": [
            "import java.util.HashSet;",
            "import java.util.ArrayList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Set<${2:Type}> ${3:setName} = new HashSet<>();",
            "        ${3:setName}.add(${4:element}); // Add element",
            "        ${3:setName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:setName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:setName}.size(); // Get the size of the set",
            "        ${3:setName}.clear(); // Clear the set",
            "    }",
            "}"
        ],
        "description": "Full HashSetArrayList initialization and common methods"
    },
    "Java ArrayListHashSetFull": {
        "prefix": "fullArrayListHashSet",
        "body": [
            "import java.util.ArrayList;",
            "import java.util.HashSet;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Set<${2:Type}> ${3:setName} = new HashSet<>();",
            "        ${3:setName}.add(${4:element}); // Add element",
            "        ${3:setName}.remove(${4:element}); // Remove element",
            "        boolean contains = ${3:setName}.contains(${4:element}); // Check if contains element",
            "        int size = ${3:setName}.size(); // Get the size of the set",
            "        ${3:setName}.clear(); // Clear the set",
            "    }",
            "}"
        ],
        "description": "Full ArrayListHashSet initialization and common methods"
    },
    "Java LinkedListHashMapFull": {
        "prefix": "fullLinkedListHashMap",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.HashMap;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new HashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full LinkedListHashMap initialization and common methods"
    },
    "Java HashMapLinkedListFull": {
        "prefix": "fullHashMapLinkedList",
        "body": [
            "import java.util.HashMap;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new HashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full HashMapLinkedList initialization and common methods"
    },
    "Java HashMapArrayListFull": {
        "prefix": "fullHashMapArrayList",
        "body": [
            "import java.util.HashMap;",
            "import java.util.ArrayList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new HashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full HashMapArrayList initialization and common methods"
    },
    "Java ArrayListHashMapFull": {
        "prefix": "fullArrayListHashMap",
        "body": [
            "import java.util.ArrayList;",
            "import java.util.HashMap;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new HashMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full ArrayListHashMap initialization and common methods"
    },
    "Java LinkedListTreeMapFull": {
        "prefix": "fullLinkedListTreeMap",
        "body": [
            "import java.util.LinkedList;",
            "import java.util.TreeMap;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new TreeMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full LinkedListTreeMap initialization and common methods"
    },
    "Java TreeMapLinkedListFull": {
        "prefix": "fullTreeMapLinkedList",
        "body": [
            "import java.util.TreeMap;",
            "import java.util.LinkedList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new TreeMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full TreeMapLinkedList initialization and common methods"
    },
    "Java TreeMapArrayListFull": {
        "prefix": "fullTreeMapArrayList",
        "body": [
            "import java.util.TreeMap;",
            "import java.util.ArrayList;",
            "",
            "public class ${1:ExampleClass} {",
            "    public static void main(String[] args) {",
            "        Map<${2:KeyType}, ${3:ValueType}> ${4:mapName} = new TreeMap<>();",
            "        ${4:mapName}.put(${5:key}, ${6:value}); // Add key-value pair",
            "        ${3:ValueType} value = ${4:mapName}.get(${5:key}); // Get value by key",
            "        ${4:mapName}.remove(${5:key}); // Remove key-value pair",
            "        boolean containsKey = ${4:mapName}.containsKey(${5:key}); // Check if contains key",
            "        boolean containsValue = ${4:mapName}.containsValue(${6:value}); // Check if contains value",
            "        int size = ${4:mapName}.size(); // Get the size of the map",
            "        ${4:mapName}.clear(); // Clear the map",
            "    }",
            "}"
        ],
        "description": "Full TreeMapArrayList initialization and common methods"
    }
}